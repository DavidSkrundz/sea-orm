use log::info;

mod user {
    use sea_orm::entity::prelude::*;

    #[sea_orm::model]
    #[derive(Clone, Debug, PartialEq, Eq, DeriveEntityModel)]
    #[sea_orm(table_name = "user")]
    pub struct Model {
        #[sea_orm(primary_key)]
        pub id: i32,
        pub name: String,
        #[sea_orm(unique)]
        pub email: String,
        #[sea_orm(has_one)]
        pub profile: HasOne<super::profile::Entity>,
        #[sea_orm(has_many)]
        pub posts: HasMany<super::post::Entity>,
    }

    impl ActiveModelBehavior for ActiveModel {}
}

mod profile {
    use sea_orm::entity::prelude::*;

    #[sea_orm::model]
    #[derive(Clone, Debug, PartialEq, Eq, DeriveEntityModel)]
    #[sea_orm(table_name = "profile")]
    pub struct Model {
        #[sea_orm(primary_key)]
        pub id: i32,
        pub picture: String,
        #[sea_orm(unique)]
        pub user_id: i32,
        #[sea_orm(belongs_to, from = "user_id", to = "id")]
        pub user: HasOne<super::user::Entity>,
    }

    impl ActiveModelBehavior for ActiveModel {}
}

mod post {
    use sea_orm::entity::prelude::*;

    #[sea_orm::model]
    #[derive(Clone, Debug, PartialEq, Eq, DeriveEntityModel)]
    #[sea_orm(table_name = "post")]
    pub struct Model {
        #[sea_orm(primary_key)]
        pub id: i32,
        pub user_id: i32,
        pub body: String,
        #[sea_orm(belongs_to, from = "user_id", to = "id")]
        pub author: HasOne<super::user::Entity>,
        #[sea_orm(has_many)]
        pub comments: HasMany<super::comment::Entity>,
    }

    impl ActiveModelBehavior for ActiveModel {}
}

mod comment {
    use sea_orm::entity::prelude::*;

    #[sea_orm::model]
    #[derive(Clone, Debug, PartialEq, Eq, DeriveEntityModel)]
    #[sea_orm(table_name = "comment")]
    pub struct Model {
        #[sea_orm(primary_key)]
        pub id: i32,
        pub comment: String,
        pub user_id: i32,
        pub post_id: i32,
        #[sea_orm(belongs_to, from = "user_id", to = "id")]
        pub user: HasOne<super::user::Entity>,
        #[sea_orm(belongs_to, from = "post_id", to = "id")]
        pub post: HasOne<super::post::Entity>,
    }

    impl ActiveModelBehavior for ActiveModel {}
}

#[tokio::main]
async fn main() -> Result<(), sea_orm::DbErr> {
    let env = env_logger::Env::default().filter_or("RUST_LOG", "info,sea_orm=debug,sqlx=warn");
    env_logger::Builder::from_env(env).init();

    use sea_orm::entity::*;

    let db = &sea_orm::Database::connect("sqlite::memory:").await?;

    // All entities defined in this crate are automatically registered
    // into the schema registry, regardless of which module they live in.
    //
    // The registry may also include entities from upstream crates,
    // so here we restrict it to entities defined in this crate only.
    //
    // The order of entity definitions does not matter.
    // SeaORM resolves foreign key dependencies automatically
    // and creates the tables in the correct order with their keys.
    db.get_schema_registry("sea_orm_quickstart::*")
        .apply(db)
        .await?;

    info!("Schema created.");

    info!("Create user Bob:");
    let bob = user::ActiveModel {
        name: Set("Bob".into()),
        email: Set("bob@sea-ql.org".into()),
        ..Default::default()
    }
    .insert(db)
    .await?;

    info!("Find Bob by email:");
    assert_eq!(
        bob,
        // this method is generated by #[sea_orm::model] on unique keys
        user::Entity::find_by_email("bob@sea-ql.org")
            .one(db)
            .await?
            .unwrap()
    );

    info!("Create profile for Bob:");
    profile::ActiveModel {
        user_id: Set(bob.id),
        picture: Set("sports pose".into()),
        ..Default::default()
    }
    .insert(db)
    .await?;

    info!("Query user with profile in a single query:");
    let user_with_profile = user::Entity::find_by_id(bob.id)
        .find_also_related(profile::Entity)
        .one(db)
        .await?;
    let Some((user, Some(profile))) = user_with_profile else {
        panic!("Profile not found");
    };
    assert_eq!(user.name, "Bob");
    assert_eq!(profile.picture, "sports pose");

    info!("Update Bob's profile:");
    let mut profile = profile.into_active_model();
    profile.picture = Set("landscape".into());
    profile.save(db).await?;

    info!("Confirmed that it's been updated:");
    assert_eq!(
        profile::Entity::find_by_user_id(bob.id).all(db).await?[0].picture,
        "landscape"
    );

    info!("Bob wrote some posts:");
    post::Entity::insert_many([
        post::ActiveModel {
            user_id: Set(bob.id),
            body: Set("Lorem ipsum dolor sit amet, consectetur adipiscing elit".into()),
            ..Default::default()
        },
        post::ActiveModel {
            user_id: Set(bob.id),
            body: Set("Ut enim ad minim veniam, quis nostrud exercitation".into()),
            ..Default::default()
        },
    ])
    .exec(db)
    .await?;

    info!("Find Bob's profile and his posts:");
    let bob_posts = user::Entity::load()
        .filter_by_id(bob.id)
        .with(profile::Entity)
        .with(post::Entity)
        .one(db)
        .await?
        .unwrap();

    assert_eq!(bob_posts.name, "Bob");
    assert_eq!(bob_posts.profile.unwrap().picture, "landscape");
    assert!(bob_posts.posts[0].body.starts_with("Lorem ipsum"));
    assert!(bob_posts.posts[1].body.starts_with("Ut enim ad"));

    info!("Create a new user Alice:");
    let alice = user::ActiveModel {
        name: Set("Alice".into()),
        email: Set("alice@rust-lang.org".into()),
        ..Default::default()
    }
    .insert(db)
    .await?;

    info!("Alice commented on Bob's post:");
    let alice_comment = comment::ActiveModel {
        comment: Set("nice post!".into()),
        post_id: Set(bob_posts.posts[0].id),
        user_id: Set(alice.id),
        ..Default::default()
    }
    .insert(db)
    .await?;

    info!("Find all posts with author along with comments and who commented:");
    let posts = post::Entity::load()
        .with(user::Entity)
        .with((comment::Entity, user::Entity))
        .all(db)
        .await?;

    assert!(posts[0].body.starts_with("Lorem ipsum"));
    assert_eq!(posts[0].author.as_ref().unwrap().name, "Bob");
    assert_eq!(posts[0].comments.len(), 1);
    assert_eq!(posts[0].comments[0].comment, "nice post!");
    assert_eq!(posts[0].comments[0].user.as_ref().unwrap().name, "Alice");

    assert!(posts[1].body.starts_with("Ut enim ad"));
    assert_eq!(posts[1].author.as_ref().unwrap().name, "Bob");
    assert_eq!(posts[1].comments.len(), 0);

    info!("Delete the comment:");
    alice_comment.delete(db).await?;

    info!("Confirm the comment has been deleted:");
    let post_comments = posts[0].find_related(comment::Entity).all(db).await?;
    assert_eq!(post_comments.len(), 0);

    Ok(())
}
